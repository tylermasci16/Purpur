From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: tylermasci <mascityler@gmail.com>
Date: Fri, 10 Jun 2022 01:56:32 -0400
Subject: [PATCH] Antimalware securirtymanger perf boost by preinit craftlegacy


diff --git a/src/main/java/com/gmail/mascityler/antimalware/AntiMalwareDriver.java b/src/main/java/com/gmail/mascityler/antimalware/AntiMalwareDriver.java
index a1a8b011bca4bbda425208d04670e7b8ffc0a970..b3e7193a47bb4cc6825099b2f5c7535968f1537c 100644
--- a/src/main/java/com/gmail/mascityler/antimalware/AntiMalwareDriver.java
+++ b/src/main/java/com/gmail/mascityler/antimalware/AntiMalwareDriver.java
@@ -8,13 +8,14 @@ import optic_fusion1.antimalware.servers.runtimeprotect.callerinfo.RuntimeUtils;
 import optic_fusion1.antimalware.servers.transformers.Transformers;
 import optic_fusion1.antimalware.utils.I18n;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.legacy.CraftLegacy;
 
 import java.io.File;
 import java.lang.reflect.InvocationTargetException;
 import java.util.HashMap;
 import java.util.concurrent.Callable;
 
-public class AntiMalwareDriver {
+public final class AntiMalwareDriver {
 
     private AntiMalwareDriver() {
 
@@ -100,9 +101,24 @@ public class AntiMalwareDriver {
                 Thread.currentThread().setContextClassLoader(malware.getContextClassLoader());
                 System.out.println("Antivirus successfully initialized");
 
-
+//TODO getclassowner is lagging fix and use class loaderr and reflection checks instend of security manager
 
                 if (System.getProperty("anontimalware-transform") == null ) {
+                    if (malware.getCommandLineParser().shouldRunSecurityManager()) {
+                        //perforance - preload craftlegacy // sadly we have to turn off security manager
+//                       try {
+//                           Class.forName("org.bukkit.craftbukkit.legacy.CraftLegacy")
+//                       } catch (Throwable t) {
+//                           t.printStackTrace();
+//                       }
+
+//                       try {
+//                           Class.forName("org.bukkit.craftbukkit.util.CraftLegacy");
+//                       } catch (Throwable t) {
+//                           t.printStackTrace();
+//                       }
+
+                    }
                     istransformed=true;
                     ServerHandler handler=new InJarServerHandler(args);
                     handler.setAntiMalware(malware);
@@ -145,5 +161,5 @@ public class AntiMalwareDriver {
         return inst != null;
     }
 
-
+//TODO preload class
 }
diff --git a/src/main/java/com/gmail/mascityler/antimalware/BypassSecurityManager.java b/src/main/java/com/gmail/mascityler/antimalware/BypassSecurityManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..33e45dd4ede81eb8dd10fcb2d0624c8b7073fb76
--- /dev/null
+++ b/src/main/java/com/gmail/mascityler/antimalware/BypassSecurityManager.java
@@ -0,0 +1,263 @@
+package com.gmail.mascityler.antimalware;
+
+import optic_fusion1.antimalware.servers.runtimeprotect.AMSecurityManager;
+
+import java.io.Closeable;
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.security.Permission;
+
+public final class BypassSecurityManager extends SecurityManager implements Closeable {
+
+    private final AMSecurityManager parent;
+    private final Thread bypasser;
+
+
+
+
+    private BypassSecurityManager(AMSecurityManager parent, Thread bypasser) {
+        this.parent = parent;
+        this.bypasser = bypasser;
+    }
+    
+
+
+    public static BypassSecurityManager getHandle() {
+
+        try {
+            if (System.getSecurityManager() instanceof AMSecurityManager ams) {
+
+                BypassSecurityManager s=new BypassSecurityManager(ams,Thread.currentThread());
+                System.setSecurityManager(s) ;
+                return s;
+            } else {
+                return null;
+            }
+        } catch (Throwable t) {
+            t.printStackTrace();
+            return null;
+        }
+
+
+    }
+
+    @Override
+    public void close() throws IOException {
+
+        System.setSecurityManager(parent);
+
+    }
+
+    @Override
+    public void checkPermission(Permission perm) {
+        parent.checkPermission(perm);
+    }
+
+    @Override
+    public void checkPermission(Permission perm, Object context) {
+        parent.checkPermission(perm, context);
+    }
+
+    @Override
+    public void checkCreateClassLoader() {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkCreateClassLoader();
+    }
+
+    @Override
+    public void checkAccess(Thread t) {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkAccess(t);
+    }
+
+    @Override
+    public void checkAccess(ThreadGroup g) {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkAccess(g);
+    }
+
+    @Override
+    public void checkExit(int status) {
+        parent.checkExit(status);
+    }
+
+    @Override
+    public void checkExec(String cmd) {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkExec(cmd);
+    }
+
+    @Override
+    public void checkLink(String lib) {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkLink(lib);
+    }
+
+    @Override
+    public void checkRead(FileDescriptor fd) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkRead(fd);
+    }
+
+    @Override
+    public void checkRead(String file) {
+
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkRead(file);
+    }
+
+    @Override
+    public void checkRead(String file, Object context) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkRead(file, context);
+    }
+
+    @Override
+    public void checkWrite(FileDescriptor fd) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkWrite(fd);
+    }
+
+    @Override
+    public void checkWrite(String file) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkWrite(file);
+    }
+
+    @Override
+    public void checkDelete(String file) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkDelete(file);
+    }
+
+    @Override
+    public void checkConnect(String host, int port) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkConnect(host, port);
+    }
+
+    @Override
+    public void checkConnect(String host, int port, Object context) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkConnect(host, port, context);
+    }
+
+    @Override
+    public void checkListen(int port) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkListen(port);
+    }
+
+    @Override
+    public void checkAccept(String host, int port) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkAccept(host, port);
+    }
+
+    @Override
+    public void checkMulticast(InetAddress maddr) {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkMulticast(maddr);
+    }
+
+    @Override
+    public void checkMulticast(InetAddress maddr, byte ttl) {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkMulticast(maddr, ttl);
+    }
+
+    @Override
+    public void checkPropertiesAccess() {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkPropertiesAccess();
+    }
+
+    @Override
+    public void checkPropertyAccess(String key) {
+        if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkPropertyAccess(key);
+    }
+
+    @Override
+    public void checkPrintJobAccess() {
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkPrintJobAccess();
+    }
+
+    @Override
+    public void checkPackageAccess(String pkg) {
+
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkPackageAccess(pkg);
+    }
+
+    @Override
+    public void checkPackageDefinition(String pkg) {
+
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkPackageDefinition(pkg);
+    }
+
+    @Override
+    public void checkSetFactory() {
+
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkSetFactory();
+    }
+
+    @Override
+    public void checkSecurityAccess(String target) {
+
+                if (Thread.currentThread() == bypasser) {
+            return;
+        }
+        parent.checkSecurityAccess(target);
+    }
+}
diff --git a/src/main/java/com/gmail/mascityler/antimalware/InJarServerHandler.java b/src/main/java/com/gmail/mascityler/antimalware/InJarServerHandler.java
index 8be7863373c3bd6989d5d7ccdf5ae57ca8bef98e..493ea5fc018676528ea212162fb7ee4e4ecf19f1 100644
--- a/src/main/java/com/gmail/mascityler/antimalware/InJarServerHandler.java
+++ b/src/main/java/com/gmail/mascityler/antimalware/InJarServerHandler.java
@@ -12,7 +12,7 @@ import org.bukkit.craftbukkit.Main;
 
 import java.io.File;
 
-public class InJarServerHandler extends ServerHandler {
+public final class InJarServerHandler extends ServerHandler {
 
     private final String[] args;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index f5a490814268949894581b6caeedb53d7588a621..34e16b83020967be7929795d8f421f192491b87a 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.util;
 
+import com.gmail.mascityler.antimalware.BypassSecurityManager;
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMultimap;
@@ -380,7 +381,23 @@ public final class CraftMagicNumbers implements UnsafeValues {
             }
         } else {
             if (minimumIndex == -1) {
-                CraftLegacy.init();
+
+                // Tyler begin - Hot load
+                BypassSecurityManager mgr = BypassSecurityManager.getHandle();
+                if ( mgr != null) {
+                    try (mgr) {
+                        CraftLegacy.init();
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                    }
+                } else {
+                    // Tyler end
+                    CraftLegacy.init();
+                    // Tyler begin
+                }
+                // Tyler end
+
+
                 Bukkit.getLogger().log(Level.WARNING, "Legacy plugin " + pdf.getFullName() + " does not specify an api-version.");
             } else {
                 throw new InvalidPluginException("Plugin API version " + pdf.getAPIVersion() + " is lower than the minimum allowed version. Please update or replace it.");
